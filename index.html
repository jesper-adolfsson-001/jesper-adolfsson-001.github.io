<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>WebXR Grabbable Cube â€” Quest 2</title>
  <style>
    html, body { margin: 0; height: 100%; background: #000; }
    canvas { display: block; }
    .hint { position: fixed; left: 12px; bottom: 12px; color: #ddd; font: 14px/1.4 system-ui, sans-serif; opacity: .9; }
    .warn { position: fixed; right: 12px; bottom: 12px; color: #f88; font: 12px system-ui; opacity: .9; }
  </style>
  <!-- Import map fixes bare module specifiers like "three" in example modules -->
  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
      "three/examples/jsm/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
    }
  }
  </script>
</head>
<body>
  <div class="hint">Enter VR. Use trigger (index) to grab/release the cube. Grip also works.</div>
  <div id="warn" class="warn" hidden>WebXR not available in this browser.</div>
  <script type="module">
    // Three.js + WebXR (Quest 2) with grab interaction
    import * as THREE from 'three';
    import { VRButton } from 'three/examples/jsm/webxr/VRButton.js';
    import { XRControllerModelFactory } from 'three/examples/jsm/webxr/XRControllerModelFactory.js';

    // --- Basic scene ---
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000000);

    const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 100);
    camera.position.set(0, 1.6, 3);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.xr.enabled = true;
    renderer.xr.setReferenceSpaceType('local-floor');
    document.body.appendChild(renderer.domElement);

    // WebXR button
    if ('xr' in navigator) {
      document.body.appendChild(VRButton.createButton(renderer));
    } else {
      document.getElementById('warn').hidden = false;
    }

    // Lights
    scene.add(new THREE.HemisphereLight(0xffffff, 0x222233, 1.2));
    const dir = new THREE.DirectionalLight(0xffffff, 0.6);
    dir.position.set(1, 2, 1);
    scene.add(dir);

    // Ground grid
    const grid = new THREE.GridHelper(10, 10, 0x444444, 0x222222);
    scene.add(grid);

    // Cube (grabbable)
    const cube = new THREE.Mesh(
      new THREE.BoxGeometry(0.4, 0.4, 0.4),
      new THREE.MeshStandardMaterial({ color: 0x44aa88, metalness: 0.1, roughness: 0.6 })
    );
    cube.position.set(0, 1.6, -1.2);
    cube.castShadow = cube.receiveShadow = false;
    scene.add(cube);

    // --- Controllers ---
    const controllerModelFactory = new XRControllerModelFactory();

    const controllers = [0, 1].map((i) => {
      const controller = renderer.xr.getController(i);
      controller.userData.index = i;
      scene.add(controller);

      const grip = renderer.xr.getControllerGrip(i);
      grip.add(controllerModelFactory.createControllerModel(grip));
      scene.add(grip);

      // Small sphere to visualize the controller tip (helps debugging distance checks)
      const tip = new THREE.Mesh(new THREE.SphereGeometry(0.01), new THREE.MeshBasicMaterial({ color: 0xffffff }));
      tip.name = 'tip';
      controller.add(tip);

      return controller;
    });

    // Grab state
    const GRAB_RADIUS = 0.35; // meters
    let grabbing = null; // { controller, offset: THREE.Vector3, rotOffset: THREE.Quaternion }

    function worldPosOf(obj) {
      const v = new THREE.Vector3();
      return obj.getWorldPosition(v);
    }

    function onGrabStart() {
      const controller = this;
      const ctrlPos = worldPosOf(controller);
      const dist = ctrlPos.distanceTo(cube.position);
      if (dist <= GRAB_RADIUS) {
        grabbing = {
          controller,
          offset: cube.position.clone().sub(ctrlPos),
          rotOffset: cube.quaternion.clone().multiply(controller.quaternion.clone().invert())
        };
      }
    }

    function onGrabEnd() {
      if (grabbing && grabbing.controller === this) {
        grabbing = null;
      }
    }

    // Trigger and Grip support
    controllers.forEach((c) => {
      c.addEventListener('selectstart', onGrabStart); // trigger
      c.addEventListener('selectend', onGrabEnd);
      c.addEventListener('squeezestart', onGrabStart); // grip
      c.addEventListener('squeezeend', onGrabEnd);
    });

    // --- Animation loop ---
    renderer.setAnimationLoop((time) => {
      if (grabbing) {
        const ctrlPos = worldPosOf(grabbing.controller);
        cube.position.copy(ctrlPos).add(grabbing.offset);
        // Optionally align rotation with controller while keeping initial offset
        const current = grabbing.controller.quaternion;
        cube.quaternion.copy(current).multiply(grabbing.rotOffset);
      } else {
        // Idle spin when not grabbed
        cube.rotation.x += 0.01;
        cube.rotation.y += 0.015;
      }

      renderer.render(scene, camera);
    });

    // Resize
    addEventListener('resize', () => {
      camera.aspect = innerWidth / innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    });

    // --- Quick self-tests (console) ---
    console.assert(typeof THREE !== 'undefined', 'THREE failed to load');
    console.assert(THREE.REVISION === '160', `Expected three r160, got ${THREE.REVISION}`);
    console.assert(renderer.xr.enabled === true, 'WebXR not enabled on renderer');
  </script>
</body>
</html>
